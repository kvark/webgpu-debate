<!doctype html><html lang="en"><head><meta charset="utf8"><title>Argdown Document</title><link rel="stylesheet" href="./argdown.css"></head><body><div class="argdown"><h2 data-line="1" id="heading-shader-compilation" class="has-line heading"><span class="statement-content">Shader Compilation</span></h2><div data-line="7" class="statement has-line top-level"><span id="statement-have-createshadermodule" class="definition statement-definition definiendum top-level">[<span class="title statement-title">Have `createShaderModule`</span>]: </span><span class="statement-content top-level">WebGPU should have an API to create a shader module independently of pipelines.</span><div class="relations"><div data-line="9" class="has-line outgoing support relation"><div class="outgoing support relation-symbol"><span>+</span></div><div data-line="9" class="argument has-line"><a id="argument-vkcreateshadermodule" href="#argument-vkcreateshadermodule" class="definition argument-definition definiendum">&lt;<span class="title argument-title">vkCreateShaderModule</span>&gt;: </a><span class="statement-content">matches Vulkan's `vkCreateShaderModule`</span></div></div><div data-line="10" class="has-line outgoing support relation"><div class="outgoing support relation-symbol"><span>+</span></div><div data-line="10" class="argument has-line"><a id="argument-parsing-and-validation" href="#argument-parsing-and-validation" class="definition argument-definition definiendum">&lt;<span class="title argument-title">Parsing and validation</span>&gt;: </a><span class="statement-content">allows us to parse WGSL, build IR, and validate it. This guarantees that the only errors that could happen later on with a shader are about the shader interface.</span></div></div><div data-line="13" class="has-line outgoing attack relation"><div class="outgoing attack relation-symbol"><span>-</span></div><div data-line="13" class="argument has-line"><a id="argument-raw-non-vulkan" href="#argument-raw-non-vulkan" class="definition argument-definition definiendum">&lt;<span class="title argument-title">Raw non-Vulkan</span>&gt;: </a><span class="statement-content">on non-Vulkan, there are no low-level objects to create at this stage.</span></div></div></div></div><div data-line="15" class="statement has-line top-level"><span id="statement-gpushadermodule-should-contain-mtllibrary" class="definition statement-definition definiendum top-level">[<span class="title statement-title">`GPUShaderModule` should contain `MTLLibrary`</span>]: </span><span class="statement-content top-level">WebGPU, Metal, Vulkan, and D3D12 all have 2-stage shader compilation pipelines. Vulkan matches WebGPU in this API. `MTLLibrary` is the product of the first stage in Metal, however WebGPU implementations can not produce it in `createShaderModule`, because it requires more information about the pipeline. Same applies to HLSL/DXIL.</span><div class="relations"><div data-line="20" class="has-line outgoing support relation"><div class="outgoing support relation-symbol"><span>+</span></div><div data-line="20" class="argument has-line"><a id="argument-newlibrarywithsource" href="#argument-newlibrarywithsource" class="definition argument-definition definiendum">&lt;<span class="title argument-title">newLibraryWithSource</span>&gt;: </a><span class="statement-content">matches Metal's `newLibraryWithSource`. When Metal developers write shaders, they have to define the structure of argument buffers inside the shader code. This roughly matches WebGPU's `GPUPipelineLayout`.</span></div></div><div data-line="23" class="has-line outgoing support relation"><div class="outgoing support relation-symbol"><span>+</span></div><div data-line="23" class="argument has-line"><a id="argument-d3dcompile" href="#argument-d3dcompile" class="definition argument-definition definiendum">&lt;<span class="title argument-title">D3DCompile</span>&gt;: </a><span class="statement-content">matches D3D's `D3DCompile` - would produce HLSL/DXIL in the first stage.</span></div></div><div data-line="24" class="has-line incoming support relation"><div class="incoming support relation-symbol"><span>+&gt;</span></div><div data-line="24" class="statement has-line"><a href="#statement-have-createshadermodule" class="reference statement-reference">[<span class="title statement-title">Have `createShaderModule`</span>] </a></div></div><div data-line="25" class="has-line incoming support relation"><div class="incoming support relation-symbol"><span>+&gt;</span></div><div data-line="25" class="statement has-line"><a href="#statement-pipeline-layouts-in-createshadermodule" class="reference statement-reference">[<span class="title statement-title">Pipeline layouts in `createShaderModule`</span>] </a></div></div></div></div><div data-line="27" class="argument has-line top-level"><a id="argument-metals-createshadermodule-is-slow" href="#argument-metals-createshadermodule-is-slow" class="definition argument-definition definiendum top-level">&lt;<span class="title argument-title">Metal's `createShaderModule` is slow</span>&gt;: </a><span class="statement-content top-level">`createShaderModule` is slow, thus it makes sense to do it early before the pipelines are created. Roughly speaking, it takes as much time to generate `MTLLibrary` as it does to create an `MTLRenderPipelineState`.</span><div class="relations"><div data-line="30" class="has-line outgoing support relation"><div class="outgoing support relation-symbol"><span>+</span></div><div data-line="30" class="statement has-line"><span class="statement-content">@litherum <a href="https://github.com/gpuweb/gpuweb/issues/1064#issuecomment-695978975">showed the numbers</a> from the Metal Performance Shaders running matrix multiplication.</span></div></div><div data-line="32" class="has-line outgoing support relation"><div class="outgoing support relation-symbol"><span>+</span></div><div data-line="32" class="statement has-line"><span class="statement-content">@kvark <a href="https://github.com/gpuweb/gpuweb/issues/1064#issuecomment-700210947">showed the numbers</a> from Dota2 shaders transpiling to Metal in a Vulkan Portability implementation.</span></div></div><div data-line="34" class="has-line outgoing support relation"><div class="outgoing support relation-symbol"><span>+</span></div><div data-line="34" class="statement has-line"><span class="statement-content">@Kangz <a href="https://github.com/gpuweb/gpuweb/issues/1064#issuecomment-700210947">showed the numbers</a> with forced driver cache invalidation.</span></div></div><div data-line="36" class="has-line incoming support relation"><div class="incoming support relation-symbol"><span>+&gt;</span></div><div data-line="36" class="statement has-line"><a href="#statement-gpushadermodule-should-contain-mtllibrary" class="reference statement-reference">[<span class="title statement-title">`GPUShaderModule` should contain `MTLLibrary`</span>] </a></div></div></div></div><div data-line="38" class="argument has-line top-level"><a id="argument-full-pipeline-descriptor" href="#argument-full-pipeline-descriptor" class="definition argument-definition definiendum top-level">&lt;<span class="title argument-title">Full pipeline descriptor</span>&gt;: </a><span class="statement-content top-level">In order to create `MTLLibrary` or DXIL from WGSL code, we'd need most of the `GPURenderPipelineDescriptor` data.</span><div class="relations"><div data-line="40" class="has-line outgoing support relation"><div class="outgoing support relation-symbol"><span>+</span></div><div data-line="40" class="argument has-line"><a id="argument-need-layout" href="#argument-need-layout" class="definition argument-definition definiendum">&lt;<span class="title argument-title">Need layout</span>&gt;: </a><span class="statement-content">knowing the pipeline layout is required to assign the proper resource binding indices, as well as define Metal argument buffers.</span><div class="relations"><div data-line="42" class="has-line incoming support relation"><div class="incoming support relation-symbol"><span>+&gt;</span></div><div data-line="42" class="statement has-line"><a href="#statement-pipeline-layouts-in-createshadermodule" class="reference statement-reference">[<span class="title statement-title">Pipeline layouts in `createShaderModule`</span>] </a></div></div></div></div></div><div data-line="43" class="has-line outgoing support relation"><div class="outgoing support relation-symbol"><span>+</span></div><div data-line="43" class="argument has-line"><a id="argument-need-sample-mask" href="#argument-need-sample-mask" class="definition argument-definition definiendum">&lt;<span class="title argument-title">Need sample mask</span>&gt;: </a><span class="statement-content">On Metal, we have to implement the per-pipeline sample mask by modifying the `[[sample_mask]]` fragment shader output in code. Doing this unconditionally would disable early-Z tests, bearing a high cost on performance. So we should only inject this code in shaders that rely on the pipeline sample mask, and the value of it being non-trivial.</span></div></div><div data-line="48" class="has-line outgoing support relation"><div class="outgoing support relation-symbol"><span>+</span></div><div data-line="48" class="argument has-line"><a id="argument-need-depth-bias" href="#argument-need-depth-bias" class="definition argument-definition definiendum">&lt;<span class="title argument-title">Need depth bias</span>&gt;: </a><span class="statement-content">On drivers/platforms that don't have a proper depth bias state, we could emulate it by injecting code into vertex shaders.</span></div></div><div data-line="50" class="has-line outgoing support relation"><div class="outgoing support relation-symbol"><span>+</span></div><div data-line="50" class="argument has-line"><a id="argument-need-vertex-input" href="#argument-need-vertex-input" class="definition argument-definition definiendum">&lt;<span class="title argument-title">Need vertex input</span>&gt;: </a><span class="statement-content">Dawn and wgpu want to have an ability to implement out-of-bound checks for vertex attributes via programmable pulling on Metal. This requires vertex shader code injected.</span></div></div><div data-line="53" class="has-line outgoing support relation"><div class="outgoing support relation-symbol"><span>+</span></div><div data-line="53" class="argument has-line"><a id="argument-need-unknown" href="#argument-need-unknown" class="definition argument-definition definiendum">&lt;<span class="title argument-title">Need unknown</span>&gt;: </a><span class="statement-content">We don't know what other pipeline states we'd need in the future in order to modify/inject shader code, related to possible HW and driver bug workarounds.</span></div></div><div data-line="55" class="has-line incoming attack relation"><div class="incoming attack relation-symbol"><span>-&gt;</span></div><div data-line="55" class="statement has-line"><a href="#statement-pipeline-layouts-in-createshadermodule" class="reference statement-reference">[<span class="title statement-title">Pipeline layouts in `createShaderModule`</span>] </a></div></div><div data-line="56" class="has-line incoming support relation"><div class="incoming support relation-symbol"><span>+&gt;</span></div><div data-line="56" class="statement has-line"><a href="#statement-have-precompile-api" class="reference statement-reference">[<span class="title statement-title">Have `precompile` API</span>] </a></div></div></div></div><div data-line="58" class="statement has-line top-level"><span id="statement-pipeline-layouts-in-createshadermodule" class="definition statement-definition definiendum top-level">[<span class="title statement-title">Pipeline layouts in `createShaderModule`</span>]: </span><span class="statement-content top-level">Have an ability to provide the pipeline layouts into `createShaderModule`, per entry point.</span><div class="relations"><div data-line="60" class="has-line incoming attack relation"><div class="incoming attack relation-symbol"><span>-&gt;</span></div><div data-line="60" class="statement has-line"><a href="#statement-keep-createshadermodule" class="reference statement-reference">[<span class="title statement-title">Keep `createShaderModule`</span>] </a></div></div></div></div><div data-line="62" class="statement has-line top-level"><span id="statement-keep-createshadermodule" class="definition statement-definition definiendum top-level">[<span class="title statement-title">Keep `createShaderModule`</span>]: </span><span class="statement-content top-level">Keep the API for module creation as is, mostly matching Vulkan.</span><div class="relations"><div data-line="63" class="has-line incoming attack relation"><div class="incoming attack relation-symbol"><span>-&gt;</span></div><div data-line="63" class="statement has-line"><a href="#statement-pipeline-layouts-in-createshadermodule" class="reference statement-reference">[<span class="title statement-title">Pipeline layouts in `createShaderModule`</span>] </a></div></div><div data-line="64" class="has-line incoming support relation"><div class="incoming support relation-symbol"><span>+&gt;</span></div><div data-line="64" class="statement has-line"><a href="#statement-have-createshadermodule" class="reference statement-reference">[<span class="title statement-title">Have `createShaderModule`</span>] </a></div></div></div></div><div data-line="66" class="argument has-line top-level"><a id="argument-caches" href="#argument-caches" class="definition argument-definition definiendum top-level">&lt;<span class="title argument-title">Caches</span>&gt;: </a><span class="statement-content top-level">The combination of driver cache and browser cache can drastically reduce the number of cases where we'd have to create a new `MTLLibrary`.</span><div class="relations"><div data-line="68" class="has-line incoming support relation"><div class="incoming support relation-symbol"><span>+&gt;</span></div><div data-line="68" class="statement has-line"><a href="#statement-keep-createshadermodule" class="reference statement-reference">[<span class="title statement-title">Keep `createShaderModule`</span>] </a></div></div></div></div><div data-line="70" class="argument has-line top-level"><a id="argument-target-llvm-ir" href="#argument-target-llvm-ir" class="definition argument-definition definiendum top-level">&lt;<span class="title argument-title">Target LLVM IR</span>&gt;: </a><span class="statement-content top-level">The implementations could target AIR and DXIL directly, in which case the cost of producing it would be reduced compare to the current model that has a text format MSL or HLSL as an intermediate.</span><div class="relations"><div data-line="73" class="has-line incoming support relation"><div class="incoming support relation-symbol"><span>+&gt;</span></div><div data-line="73" class="statement has-line"><a href="#statement-keep-createshadermodule" class="reference statement-reference">[<span class="title statement-title">Keep `createShaderModule`</span>] </a></div></div></div></div><div data-line="75" class="argument has-line top-level"><a id="argument-multiple-entry-points" href="#argument-multiple-entry-points" class="definition argument-definition definiendum top-level">&lt;<span class="title argument-title">Multiple entry points</span>&gt;: </a><span class="statement-content top-level">An ideal Metal application would re-use `MTLLibrary` for multiple different entry points in the pipelines it creates. That is unlike WebGPU, where an implementation can only create `MTLLibrary` when it has a specific entry point selected, and doesn't know about any other entry points.</span><div class="relations"><div data-line="79" class="has-line incoming support relation"><div class="incoming support relation-symbol"><span>+&gt;</span></div><div data-line="79" class="statement has-line"><a href="#statement-gpushadermodule-should-contain-mtllibrary" class="reference statement-reference">[<span class="title statement-title">`GPUShaderModule` should contain `MTLLibrary`</span>] </a></div></div><div data-line="80" class="has-line incoming attack relation"><div class="incoming attack relation-symbol"><span>-&gt;</span></div><div data-line="80" class="argument has-line"><a id="" href="#argument-caches" data-line="80" class="has-line reference argument-reference">&lt;<span class="title argument-title">Caches</span>&gt; </a></div></div><div data-line="81" class="has-line incoming support relation"><div class="incoming support relation-symbol"><span>+&gt;</span></div><div data-line="81" class="argument has-line"><a id="" href="#argument-all-at-once" data-line="81" class="has-line reference argument-reference">&lt;<span class="title argument-title">All at once</span>&gt; </a></div></div></div></div><div data-line="83" class="argument has-line top-level"><a id="argument-all-at-once" href="#argument-all-at-once" class="definition argument-definition definiendum top-level">&lt;<span class="title argument-title">All at once</span>&gt;: </a><span class="statement-content top-level">Given a list of entry points with all the associated pipeline information, an implementation can create fewer `MTLLibrary` and `DXIL` objects.</span><div class="relations"><div data-line="85" class="has-line incoming support relation"><div class="incoming support relation-symbol"><span>+&gt;</span></div><div data-line="85" class="statement has-line"><a href="#statement-have-precompile-api" class="reference statement-reference">[<span class="title statement-title">Have `precompile` API</span>] </a></div></div><div data-line="86" class="has-line incoming support relation"><div class="incoming support relation-symbol"><span>+&gt;</span></div><div data-line="86" class="statement has-line"><a href="#statement-have-createreadypipelines" class="reference statement-reference">[<span class="title statement-title">Have `createReadyPipelines`</span>] </a></div></div></div></div><div data-line="88" class="argument has-line top-level"><a id="argument-combinations" href="#argument-combinations" class="definition argument-definition definiendum top-level">&lt;<span class="title argument-title">Combinations</span>&gt;: </a><span class="statement-content top-level">Users may not know ahead of time which vertex shaders are used with which fragment shaders. In Metal, they can still mix and match `MTLLibrary` use for pipeline creation.</span><div class="relations"><div data-line="90" class="has-line incoming attack relation"><div class="incoming attack relation-symbol"><span>-&gt;</span></div><div data-line="90" class="statement has-line"><a href="#statement-have-createreadypipelines" class="reference statement-reference">[<span class="title statement-title">Have `createReadyPipelines`</span>] </a></div></div></div></div><div data-line="92" class="statement has-line top-level"><span id="statement-have-precompile-api" class="definition statement-definition definiendum top-level">[<span class="title statement-title">Have `precompile` API</span>]: </span><span class="statement-content top-level">Add <a href="%5BKeep%20%60createShaderModule%60%5D">some API</a> on the `GPUShaderModule` to tell it ahead of time the bits of the pipeline that the contained entry points will be created with.</span><div class="relations"><div data-line="95" class="has-line outgoing attack relation"><div class="outgoing attack relation-symbol"><span>-</span></div><div data-line="95" class="argument has-line"><a id="argument-precompile-spec" href="#argument-precompile-spec" class="definition argument-definition definiendum">&lt;<span class="title argument-title">Precompile spec</span>&gt;: </a><span class="statement-content">it's difficult to specify this and set up the proper expectations for the users, as in: what would be the difference between hinting and not hinting, depending on the target platform.</span></div></div></div></div><div data-line="99" class="statement has-line top-level"><span id="statement-have-createreadypipelines" class="definition statement-definition definiendum top-level">[<span class="title statement-title">Have `createReadyPipelines`</span>]: </span><span class="statement-content top-level">WebGPU should have a plural `createReadyPipelines` asynchronous method.</span></div></div></body></html>