<!doctype html><html lang="en"><head><meta charset="utf8"><title>Argdown Document</title><link rel="stylesheet" href="./argdown.css"></head><body><div class="argdown"><h2 data-line="1" id="heading-structure-layout-in-wgsl" class="has-line heading"><span class="statement-content">Structure Layout in WGSL</span></h2><div data-line="19" class="statement has-line top-level"><span id="statement-offset-decorations" class="definition statement-definition definiendum top-level">[<span class="title statement-title">Offset decorations</span>]: </span><span class="statement-content top-level">We need to have a separate &quot;offset&quot; decorator on each member.</span><div class="relations"><div data-line="20" class="has-line outgoing attack relation"><div class="outgoing attack relation-symbol"><span>-</span></div><div data-line="20" class="argument has-line"><a id="argument-verbose" href="#argument-verbose" class="definition argument-definition definiendum">&lt;<span class="title argument-title">Verbose</span>&gt;: </a><span class="statement-content">sprinkling offsets is mostly mechanical, but still tedious. Each offset depends on the type of the current field as well as the previous offset.</span></div></div></div></div><div data-line="23" class="statement has-line top-level"><span class="statement-content top-level">&lt;!-- What about offsets being explicit? It's not obvious that this actually makes thing simpler. You'd still need the offsets from both sides, and to compare them. --!&gt;</span></div><div data-line="26" class="statement has-line top-level"><span id="statement-span-decorations" class="definition statement-definition definiendum top-level">[<span class="title statement-title">Span decorations</span>]: </span><span class="statement-content top-level">We need to have a &quot;span&quot; decorator on the fields with types that occupy more space in the texture than the type size is.</span><div class="relations"><div data-line="28" class="has-line outgoing attack relation"><div class="outgoing attack relation-symbol"><span>-</span></div><div data-line="28" class="argument has-line"><a id="argument-context" href="#argument-context" class="definition argument-definition definiendum">&lt;<span class="title argument-title">Context</span>&gt;: </a><span class="statement-content">it's easy to miss the fact that a span of a field actually depends on the type of the next field, since a type dictates the alignment.</span></div></div></div></div><div data-line="31" class="argument has-line top-level"><a id="argument-automation" href="#argument-automation" class="definition argument-definition definiendum top-level">&lt;<span class="title argument-title">Automation</span>&gt;: </a><span class="statement-content top-level">given knowledge of where a structure is used (uniform vs storage buffers), figuring out the structure layout is mechanical. We shouldn't require the user to do this by hand if we are going to be computing it ourselves.</span><div class="relations"><div data-line="34" class="has-line incoming support relation"><div class="incoming support relation-symbol"><span>+&gt;</span></div><div data-line="34" class="statement has-line"><a href="#statement-span-decorations" class="reference statement-reference">[<span class="title statement-title">Span decorations</span>] </a></div></div><div data-line="35" class="has-line incoming support relation"><div class="incoming support relation-symbol"><span>+&gt;</span></div><div data-line="35" class="statement has-line"><a href="#statement-layout-decoration" class="reference statement-reference">[<span class="title statement-title">Layout decoration</span>] </a></div></div></div></div><div data-line="37" class="argument has-line top-level"><a id="argument-padding" href="#argument-padding" class="definition argument-definition definiendum top-level">&lt;<span class="title argument-title">Padding</span>&gt;: </a><span class="statement-content top-level">if the user needs extra padding, they can insert it themselves. Most users don't need extra padding, so inventing language tools to address this need is too heavy-handed.</span><div class="relations"><div data-line="40" class="has-line incoming support relation"><div class="incoming support relation-symbol"><span>+&gt;</span></div><div data-line="40" class="argument has-line"><a id="" href="#argument-automation" data-line="40" class="has-line reference argument-reference">&lt;<span class="title argument-title">Automation</span>&gt; </a></div></div><div data-line="41" class="has-line outgoing support relation"><div class="outgoing support relation-symbol"><span>+</span></div><div data-line="41" class="argument has-line"><a id="argument-rich-types" href="#argument-rich-types" class="definition argument-definition definiendum">&lt;<span class="title argument-title">Rich types</span>&gt;: </a><span class="statement-content">Where necessary, we can introduce the types with different layout. For example, a `vec3w` would take as much space as `vec4`.</span></div></div></div></div><div data-line="44" class="statement has-line top-level"><span id="statement-layout-decoration" class="definition statement-definition definiendum top-level">[<span class="title statement-title">Layout decoration</span>]: </span><span class="statement-content top-level">We just need a decoration on the struct itself. Based on the layout, we can compute the layout of the fields.</span><div class="relations"><div data-line="46" class="has-line outgoing support relation"><div class="outgoing support relation-symbol"><span>+</span></div><div data-line="46" class="argument has-line"><a id="argument-easy-validation" href="#argument-easy-validation" class="definition argument-definition definiendum">&lt;<span class="title argument-title">Easy validation</span>&gt;: </a><span class="statement-content">once you see a structure with a concrete layout, it's clear whether this structure can be used in uniform or storage buffers.</span></div></div></div></div><div data-line="49" class="statement has-line top-level"><span class="statement-content top-level">&lt;!-- What about proliferation of different layout types, e.g. &quot;relaxed&quot; and &quot;scalar&quot;? My understanding is that if we add any of those, we'd still have to specify what requirements they have on spans/offsets, so the constraints are in place. The question becomes more of whether the constraints are explicit or implicit. --!&gt;</span></div><div data-line="54" class="statement has-line top-level"><span id="statement-unified-layout" class="definition statement-definition definiendum top-level">[<span class="title statement-title">Unified layout</span>]: </span><span class="statement-content top-level">We should define one and only layout enforced in all host-shareable structs.</span><div class="relations"><div data-line="55" class="has-line outgoing attack relation"><div class="outgoing attack relation-symbol"><span>-</span></div><div data-line="55" class="argument has-line"><a id="argument-storage" href="#argument-storage" class="definition argument-definition definiendum">&lt;<span class="title argument-title">Storage</span>&gt;: </a><span class="statement-content">Storage buffers can use a more tight layout, and for many users this makes a solid difference in performance.</span></div></div></div></div></div></body></html>